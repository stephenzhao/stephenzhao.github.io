<!DOCTYPE html>
<html lang="zh-CN">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keyword"  content="赵飞, 赵飞博客, Damon, Damon Blog, 个人网站, 博客, 个人网站, 互联网, 前端, 设计, 产品">
    <link rel="shortcut icon" href="/favicon.ico">
    <meta name="baidu-site-verification" content="FAGkDXqvn4" />
    <!--Description-->
    
        <meta name="description" content="Damon 的博客，学习总结 思考感悟 知识管理">
    

    <!--Author-->
    
        <meta name="author" content="damon">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="一篇文章讲清楚Ract的10大基础概念"/>
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="Damon"/>

    <!--Page Cover-->
    
        <meta property="og:image" content="undefined"/>
    

    <!-- Title -->
    
    <title>一篇文章讲清楚Ract的10大基础概念 - Damon</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/bootstrap/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/bootstrap/css/syntax.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <link href="http://cdn.staticfile.org/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <!-- <link href="//cdn.rawgit.com/noelboss/featherlight/1.3.5/release/featherlight.min.css" type="text/css" rel="stylesheet" /> -->

</head>

<body>

    <!-- Menu -->
    <!-- Navigation -->

<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">
                
                    <img height="30px" alt="Damon" src="/img/logo_yellow.png">
                
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="blog-navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    
                        <li>
                            <a href="/">Home</a>
                        </li>
                    
                        <li>
                            <a href="/archives">Archives</a>
                        </li>
                    
                        <li>
                            <a href="/about">About</a>
                        </li>
                    
                        <li>
                            <a href="/webpack-cn">Webpackdoc</a>
                        </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#blog-navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from
     * $toggle/$collapse will break global delegation.
     *
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->


    <style type="text/css">
    
    </style>
<header class="intro-header" style="background-image: url('https://uploadbeta.com/api/pictures/random/?key=BingEverydayWallpaperPicture'); background-size: cover; position: relative;">
        <div class="header-mask"></div>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                         <!-- Tags and categories -->
                       
                                
                                    


<a class="tag" href="/tags/react/">react</a> <a class="tag" href="/tags/前端开发/">前端开发</a>


                                
                                
                        

                    </div>
                    <h1>一篇文章讲清楚Ract的10大基础概念</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        2017-08-24
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container post-container">
        <div class="row">

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <p><img src="https://cdn-images-1.medium.com/max/800/1*qUlxDdY3T-rDtJ4LhLGkEg.png" alt="logo"></p>
<p>这篇文章不是讲什么是React，也不是<a href="https://medium.freecodecamp.org/yes-react-is-taking-over-front-end-development-the-question-is-why-40837af8ab76" target="_blank" rel="external">为什么学习React</a>。 而是一篇介绍React的一些基本概念和原理，我假定你们都熟悉js也了解基本的DOM API。</p>
<p>文章中的所有代码例子都只是作为参考，它们可能有别的更好的写法，但这里纯粹的为了理解React概念。</p>
<h1 id="1-React皆组件"><a href="#1-React皆组件" class="headerlink" title="#1: React皆组件"></a>#1: React皆组件</h1><p>React按照可复用组件的概念来设计的。定义一个个的小组件，然后组装成大组件。</p>
<p>所有的组件不论大小都是可复用的，即使跨项目也一样。</p>
<p>一个组件，从形式上看就是一个普通的JS函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 例1</span><br><span class="line">// https://jscomplete.com/repl?j=Sy3QAdKHW</span><br><span class="line">function Button (props) &#123;</span><br><span class="line">  // Returns a DOM element here. For example:</span><br><span class="line">  return &lt;button type="submit"&gt;&#123;props.label&#125;&lt;/button&gt;;</span><br><span class="line">&#125;</span><br><span class="line">// To render the Button component to the browser</span><br><span class="line">ReactDOM.render(&lt;Button label="Save" /&gt;, mountNode)</span><br></pre></td></tr></table></figure>
<p>关于 <code>Button</code> 里面的花括号，还有ReactDOM会在后面介绍。这里只是一个热身例子。</p>
<p>ReactDOM.render 的第二个参数是React会覆盖和监控的目标元素。</p>
<p>关于 例1 的个要点:</p>
<ul>
<li>问了和HTML标签区别开来，组件的名字首字母大写。小写是为HTML元素预留的，事实上如果你把该组件命名为’button’，ReactDOM将会忽略此函数直接渲染一个正常的空的HTML button。</li>
<li>和HTML元素一样每个组件也会接收一个属性列表，在React里面这个列表叫Props。由于是一个函数组件你可以随便定义属性。</li>
<li>在Button函数组件上，我们写出了一个类HTML的输出。这种输出既不JS也不是HTML或者React.js。但它是这么的受欢迎以至于变成了React的默认写法。她叫做JSX，一个JS的扩展。JSX也是一种折衷的方案。自己动手试试吧，比如试试让她返回一个input元素。</li>
</ul>
<h1 id="2-JSX的-“flux”-是多少"><a href="#2-JSX的-“flux”-是多少" class="headerlink" title="#2: JSX的 “flux” 是多少?"></a>#2: JSX的 “flux” 是多少?</h1><p>上面的例子例1可以用纯react.js实现,而不用jsx:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例2 -  React component without JSX</span></span><br><span class="line"><span class="comment">// https://jscomplete.com/repl?j=HyiEwoYB-</span></span><br><span class="line"><span class="function">function <span class="title">Button</span> <span class="params">(props)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(</span><br><span class="line">    <span class="string">"button"</span>,</span><br><span class="line">    &#123; type: <span class="string">"submit"</span> &#125;,</span><br><span class="line">    props.label</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// To use Button, you would do something like</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  React.createElement(Button, &#123; label: <span class="string">"Save"</span> &#125;),</span><br><span class="line">  mountNode</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>createElement函数是React顶级API的主要函数。也是7大API中所需要学习的一个。这也说明了ReactAPI很小。</p>
<p>就类似DOM有自己的document.createElement 函数来创建特定标签名的元素。React的createElement函数是一个高级函数能做到document.createElement能做的事，他也能创建代表React组件的元素。我们在上面的例子2中做过后者。</p>
<p>不一样的还有，React的createElement函数接受一个可变的多个参数做为第二个参数后面的参数来代表创建的元素的子元素。所以CreatElement实际是创建了一个树</p>
<p>举个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例3 -  React’s createElement API</span></span><br><span class="line"><span class="comment">// https://jscomplete.com/repl?j=r1GNoiFBb</span></span><br><span class="line"><span class="keyword">const</span> InputForm = React.createElement(</span><br><span class="line">  <span class="string">"form"</span>,</span><br><span class="line">  &#123; target: <span class="string">"_blank"</span>, action: <span class="string">"https://google.com/search"</span> &#125;,</span><br><span class="line">  React.createElement(<span class="string">"div"</span>, <span class="keyword">null</span>, <span class="string">"Enter input and click Search"</span>),</span><br><span class="line">  React.createElement(<span class="string">"input"</span>, &#123; className: <span class="string">"big-input"</span> &#125;),</span><br><span class="line">  React.createElement(Button, &#123; label: <span class="string">"Search"</span> &#125;)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// InputForm uses the Button component, so we need that too:</span></span><br><span class="line"><span class="function">function <span class="title">Button</span> <span class="params">(props)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(</span><br><span class="line">    <span class="string">"button"</span>,</span><br><span class="line">    &#123; type: <span class="string">"submit"</span> &#125;,</span><br><span class="line">    props.label</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Then we can use InputForm directly with .render</span></span><br><span class="line">ReactDOM.render(InputForm, mountNode);</span><br></pre></td></tr></table></figure>
<p>从上面列子需要知道：</p>
<ol>
<li><p>因为InputForm不是React组件，只是React元素。所以我们直接用ReactDOM.render来调用InputForm，而不是 <inputform>（注意和例1的对比）。</inputform></p>
</li>
<li><p>React.createElement 函数在前两个参数后面接收了多个参数. 他从第三个起的参数列表 由一个该组件的子组件构成的列表.</p>
</li>
<li><p>由于 React.createElement 都是 JavaScript所以我们可以嵌套调用.当该元素没有属性或者Props的时候，该函数的第二个参数可以是null或者是一个空的对象.</p>
</li>
<li><p>我们可以将HTML元素和React组件一起混用，你就把HTML想象为React的内置组件就可以了.</p>
</li>
<li><p>React 的API设计会尽可能的河DOM API接近，这也是为什么在 Input 元素中我们要用className而不是class的原因. 私下里,我们都希望React API可以变成DOM API的一部分，那就太好了.</p>
</li>
</ol>
<p>上面的代码当引入了React库后浏览器是可以理解的，浏览器不能直接解析JSX. 然而我们开发者喜欢跟HMTL打交道而不是createElment（想象一下，整个页面用document.createElement来创建的情景，辣眼睛）. 这就是JSX存在的意义，以其用React.createElement来构建页面，我们更愿意使用一种和HTML更相近的语法:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 例4 - JSX (compare with 例3)</span><br><span class="line">// https://jscomplete.com/repl?j=SJWy3otHW</span><br><span class="line">const InputForm =</span><br><span class="line">  &lt;form target="_blank" action="https://google.com/search"&gt;</span><br><span class="line">    &lt;div&gt;Enter input and click Search&lt;/div&gt;</span><br><span class="line">    &lt;input className="big-input" name="q" /&gt;</span><br><span class="line">    &lt;Button label="Search" /&gt;</span><br><span class="line">  &lt;/form&gt;;</span><br><span class="line">// InputForm "still" uses the Button component, so we need that too.</span><br><span class="line">// Either JSX or normal form would do</span><br><span class="line">function Button (props) &#123;</span><br><span class="line">  // Returns a DOM element here. For example:</span><br><span class="line">  return &lt;button type="submit"&gt;&#123;props.label&#125;&lt;/button&gt;;</span><br><span class="line">&#125;</span><br><span class="line">// Then we can use InputForm directly with .render</span><br><span class="line">ReactDOM.render(InputForm, mountNode);</span><br></pre></td></tr></table></figure>
<p>上面例子你需要知道：</p>
<ul>
<li>它们不是HTML，你可以看到我们还在用className而不是class.</li>
<li>我们一直认为这种类HTML的语法是一种JS，所以可以看到我们在最后加了分号。</li>
</ul>
<p>上面的代码（例4）就是JSX了。到目前为止，我们呈现给浏览器的是（例3）版本编译后的代码。为了达到被浏览器理解的目的，我们需要使用与处理器来讲JSX版本（例4）的代码转换成为React.createElement（例3）版本。</p>
<p>这就是JSX，它是为了让我们能够用一种更接近HTML语法来写React组件的一种折衷的办法，也是一个不错的方案。</p>
<blockquote>
<p>开头说的“Flux”这个单词，其实只是为了押韵所以用了这个词。Flux同时也是一个Facebook推出的非常受欢迎的应用框架的名字。其中最出名的实现是Redux。Flux非常适用于React的reactive特性.</p>
</blockquote>
<p>另外，JSX也不是非得和React搭配用的，他也可以独立使用.</p>
<h1 id="3-你可以在-JSX任何位置使用JS表达式"><a href="#3-你可以在-JSX任何位置使用JS表达式" class="headerlink" title="#3: 你可以在 JSX任何位置使用JS表达式"></a>#3: 你可以在 JSX任何位置使用JS表达式</h1><p>在JSX里面，你可以使用带有花括号的JS表达式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 例5 -  Using JavaScript expressions in JSX</span><br><span class="line">// https://jscomplete.com/repl?j=SkNN3oYSW</span><br><span class="line">const RandomValue = () =&gt; </span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123; Math.floor(Math.random() * 100) &#125;</span><br><span class="line">  &lt;/div&gt;;</span><br><span class="line">// To use it:</span><br><span class="line">ReactDOM.render(&lt;RandomValue /&gt;, mountNode);</span><br></pre></td></tr></table></figure>
<p>任何JS表达式都可以放到花括号里面，这有点像<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="external">JS字符串模版</a>里面的${} 插值语法.</p>
<p>唯一的约束是：只能是JS表达式，比如：if 语句不能使用了，但是你可以用三元表达式来代替.</p>
<p>JS变量是表达式，所以当组件接收到Props列表（除了随机数外，props是可选的）时，我们可以将其使用到花括号里面。我们在(例1)里面的Button组件使用过。</p>
<p>JS对象也同样是表达式。有时候我们在花括号里面使用JS对象，从表现上来看是一个双括号，但这实际上就是一个放在花括号里面的对象而已。比如，我们可以在React的特殊样式属性中传入一个CSS样式对象:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 例6 - An object passed to the special React style prop</span><br><span class="line">// https://jscomplete.com/repl?j=S1Kw2sFHb</span><br><span class="line">const ErrorDisplay = (&#123;message&#125;) =&gt;</span><br><span class="line">  &lt;div style=&#123; &#123; color: 'red', backgroundColor: 'yellow' &#125; &#125;&gt;</span><br><span class="line">    &#123;message&#125;</span><br><span class="line">  &lt;/div&gt;;</span><br><span class="line">// Use it:</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;ErrorDisplay </span><br><span class="line">    message="These aren't the droids you're looking for" </span><br><span class="line">  /&gt;,</span><br><span class="line">  mountNode</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>注意这里我是怎么结构props里面的message参数的，再次证明它是JS。另外注意看一下style属性的特殊性（它不是HTML，它只是接近DOM API）。我们使用一个对象作为style属性。这样的定义样式就像在写js一样，当然我们就是在写JS。</p>
<p>由于React元素也是一个表达式，所以同样我们可以在JSX中使用。别忘了React元素其实就是一个函数调用:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 例7 - Using a React element within &#123;&#125;</span><br><span class="line">// https://jscomplete.com/repl?j=SkTLpjYr-</span><br><span class="line">const MaybeError = (&#123;errorMessage&#125;) =&gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;errorMessage &amp;&amp; <span class="tag">&lt;<span class="name">ErrorDisplay</span> <span class="attr">message</span>=<span class="string">&#123;errorMessage&#125;</span> /&gt;</span>&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>;</span><br><span class="line">  </span><br><span class="line">// The MaybeError component uses the ErrorDisplay component:</span><br><span class="line">const ErrorDisplay = (&#123;message&#125;) =&gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;</span> &#123; <span class="attr">color:</span> '<span class="attr">red</span>', <span class="attr">backgroundColor:</span> '<span class="attr">yellow</span>' &#125; &#125;&gt;</span></span><br><span class="line">    &#123;message&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>;</span><br><span class="line">// Now we can use the MaybeError component:</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="tag">&lt;<span class="name">MaybeError</span></span><br><span class="line">    <span class="attr">errorMessage</span>=<span class="string">&#123;Math.random()</span> &gt;</span> 0.5 ? 'Not good' : ''&#125;</span><br><span class="line">  /&gt;,</span><br><span class="line">  mountNode</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面的 MaybeError 组件，如果有errorMessage传入将展示ErrorDisplay组件. React 会将 {true}, {false}, {undefined}, 和 {null} 视为有效的子元素,只不过不显示出来罢了.</p>
<p>你还可以在JSX里使用函数式集合方法（map, reduce, filter, concat等等），因为它们返回的也是一个表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 例8 - Using an array map inside &#123;&#125;</span><br><span class="line">// https://jscomplete.com/repl?j=SJ29aiYH-</span><br><span class="line">const Doubler = (&#123;value=[1, 2, 3]&#125;) =&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;value.map(e =&gt; e * 2)&#125;</span><br><span class="line">  &lt;/div&gt;;</span><br><span class="line">// Use it</span><br><span class="line">ReactDOM.render(&lt;Doubler /&gt;, mountNode);</span><br></pre></td></tr></table></figure>
<p>上面的例子，我给了属性一个默认值，同样还在div里面输出了一个数组表达式。React接受这种操作，他将把每一个乘以二后的数字用text node 展示出来.</p>
<h1 id="4-你可以用JS-class-来写React组件"><a href="#4-你可以用JS-class-来写React组件" class="headerlink" title="#4: 你可以用JS class 来写React组件"></a>#4: 你可以用JS class 来写React组件</h1><p>简单函数组件只能满足简单需求，但实际开发中我们需要更复杂的组件。  React 支持通过<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="external">class语法</a>来写组件. 这里给出上面的Button例子的改写:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 例9 - Creating components using JavaScript classes</span><br><span class="line">// https://jscomplete.com/repl?j=ryjk0iKHb</span><br><span class="line">class Button extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;button&gt;&#123;this.props.label&#125;&lt;/button&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Use it (same syntax)</span><br><span class="line">ReactDOM.render(&lt;Button label="Save" /&gt;, mountNode);</span><br></pre></td></tr></table></figure>
<p>class语法很简答. 定义一个继承自React.Component（另一个顶级React API）的class. 这个 class 定义了一个单例函数 render(), 该函数返回一个 virtual DOM 对象. 当我们使用这个class-based 的 Button组件的时候 (例如, <button ...="">), React 将从这个 class-based 组件实例化一个对象并将该对象放入 DOM 树中.</button></p>
<p>这就是为什么我们要在render函数里的JSX上使用<code>this.props.label</code>.  当组件初始化的时候每一个组件实例都会有一个专有的实例属性<code>props</code>传给组件实例.</p>
<p>既然我们有一个和单一组件使用有关的实例，那么我们可以按照意愿修改该实例。例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 例10 -  Customizing a component instance</span><br><span class="line">// https://jscomplete.com/repl?j=rko7RsKS-</span><br><span class="line">class Button extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.id = Date.now();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;button id=&#123;this.id&#125;&gt;&#123;this.props.label&#125;&lt;/button&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Use it</span><br><span class="line">ReactDOM.render(&lt;Button label="Save" /&gt;, mountNode);</span><br></pre></td></tr></table></figure>
<p>我们也可以自定义属性方法并在组件任何地方使用它:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 例11 — Using class properties</span><br><span class="line">// https://jscomplete.com/repl?j=H1YDCoFSb</span><br><span class="line">class Button extends React.Component &#123;</span><br><span class="line">  clickCounter = 0;</span><br><span class="line">handleClick = () =&gt; &#123;</span><br><span class="line">    console.log(`Clicked: $&#123;++this.clickCounter&#125;`);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button id=&#123;this.id&#125; onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line">        &#123;this.props.label&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Use it</span><br><span class="line">ReactDOM.render(&lt;Button label="Save" /&gt;, mountNode);</span><br></pre></td></tr></table></figure>
<p>在上面的例子里:</p>
<ul>
<li>handleClick 函数 使用的是新的类域语法. 它还处在 stage-2阶段,但是这是最好的使用组件实例的方式（感谢尖头函数的出现）.但是，你需要用Babel这样的编译器，来让浏览器认识这些新语法. 网上有babel相关的资料大家可以看看.</li>
<li>我们也同样用了类域语法定义了<code>clickCounter</code>变量，这让我们省略了类构造函数的使用。</li>
<li>当我们指定<code>handleClick</code>函数作为React专有属性onClick的属性值，我们没有调用该函数，我们只是传了一个该函数的引用. 在那个级别调用方法是写React一个常犯的错误.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Wrong:</span><br><span class="line">onClick=&#123;this.handleClick()&#125;</span><br><span class="line">// Right:</span><br><span class="line">onClick=&#123;this.handleClick&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-React的事件-两大不同"><a href="#5-React的事件-两大不同" class="headerlink" title="#5: React的事件: 两大不同"></a>#5: React的事件: 两大不同</h1><p>在遇到React事件的时候，我们需要知道两个不同于DOM API的点:</p>
<ul>
<li><p>所有的react元素属性都适用驼峰命名而不是小写. 如：<code>onClick</code> 非 <code>onclick</code>.</p>
</li>
<li><p>我们传递的是函数的应用作为事件的处理器而不是字符串。如： <code>onClick={handleClick}</code>, 非 <code>onClick=&quot;handleClick&quot;</code>.</p>
</li>
</ul>
<p>React 把DOM的事件对象包装到了自己的对象里面，并对事件处理的性能做了优化。但是在事件处理器里面我们同样可以使用DOM事件对象里面的所有可用方法。每一次事件调用React都会将该包装后的事件对象传递过去. 例如，禁用form表单的默认提交事件可以这么做:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 例12 - Working with wrapped events</span><br><span class="line">// https://jscomplete.com/repl?j=HkIhRoKBb</span><br><span class="line">class Form extends React.Component &#123;</span><br><span class="line">  handleSubmit = (event) =&gt; &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    console.log(&apos;Form submitted&apos;);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Use it</span><br><span class="line">ReactDOM.render(&lt;Form /&gt;, mountNode);</span><br></pre></td></tr></table></figure>
<h1 id="6-每个组件都有一个生命周期"><a href="#6-每个组件都有一个生命周期" class="headerlink" title="#6: 每个组件都有一个生命周期"></a>#6: 每个组件都有一个生命周期</h1><p>下面几点仅适用于class-based组件(继承自 React.Component). function-based的组件稍有不同.</p>
<ol>
<li><p>定义一个让React创建元素的模版.</p>
</li>
<li><p>然后, 我们委托React来使用它。比如，ReactDOM.render里，或者别的组件的render方法里。</p>
</li>
<li><p>接着，React实例化一个元素并传入一个props集合，这个集合我们可以通过<code>this.props</code>来访问. 这些props实际上是通过上面第二步传入的.</p>
</li>
<li><p>由于都是JS，其构造函数将会被调用（如果定义了的话）. 这也是我们所说的第一个组件生命周期函数.</p>
</li>
<li><p>React会计算出render函数输出的结果 ( virtual DOM 节点).</p>
</li>
<li><p>这个时候React开始渲染元素, React 将会和浏览器通信 (对于我们来说就是开始使用DOM API) 将元素展示到浏览器里. 这个过程被叫做 mounting.</p>
</li>
<li><p>接着React开始启用另一个生命周期方法 componentDidMount. 我们可以利用这个方法，例如，可以在这里操作DOM. 早于这个方法的DOM都是虚拟DOM.</p>
</li>
<li><p>有些组件生命到这里就结束了.其他的组建将会由于各种各样的原因收到浏览器DOM的unmounted状态 . 如果后者发生，此时React 将启用componentWillUnmount.</p>
</li>
<li><p>装在后的元素的状态可能发生改变. 父元素也可能重新渲染.同时，装在后的element也可以接受到一个不同的props.React的神奇就在这里! 这也是我们为什么需要React的原因.</p>
</li>
<li><p>组件生命继续,在此之前我们先来理解一下什么是state.</p>
</li>
</ol>
<h1 id="7-每个组件都有一个私有状态state"><a href="#7-每个组件都有一个私有状态state" class="headerlink" title="#7: 每个组件都有一个私有状态state"></a>#7: 每个组件都有一个私有状态state</h1><p>下面的内容也仅适用于class-based组件。</p>
<p>State 类域在React class组件都是特有的。React监视这个每一个组件的state的改变。为了高效的实现这个机制，我们需要通过另外一个顶级的React API来修改state，那就是<code>this.setState</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 例13 -  the setState API</span><br><span class="line">// https://jscomplete.com/repl?j=H1fek2KH-</span><br><span class="line">class CounterButton extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    clickCounter: 0,</span><br><span class="line">    currentTimestamp: new Date(),</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    this.setState((prevState) =&gt; &#123;</span><br><span class="line">     return &#123; clickCounter: prevState.clickCounter + 1 &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">   setInterval(() =&gt; &#123;</span><br><span class="line">     this.setState(&#123; currentTimestamp: new Date() &#125;)</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.handleClick&#125;&gt;Click&lt;/button&gt;</span><br><span class="line">        &lt;p&gt;Clicked: &#123;this.state.clickCounter&#125;&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;Time: &#123;this.state.currentTimestamp.toLocaleString()&#125;&lt;/p&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// Use it</span><br><span class="line">ReactDOM.render(&lt;CounterButton /&gt;, mountNode);</span><br></pre></td></tr></table></figure>
<p>这是一个需要理解的很重要的例子。这将完善你的React的知识。理解了这个例子后，你只需要在学习一点JS技巧方面的知识就可以入门了。</p>
<p>从class域开始让我们回顾一下例13。有两个类域。<br>第一个是私有state，它包含两个属性<code>clickCounter</code> 和 <code>currentTimestamp</code>.<br>另一个是<code>handleClick</code>函数，该函数的引用被传给button的onClick 事件属性。它会通过setState来改变组件的状态。</p>
<p>另外我们还在componentDidMount方法里面调用一个定时轮询来改变状态，每秒调用一下this.setState。<br>在render函数里我们就使用了一下这两个属性，没别的特殊API。</p>
<p>Now, notice that we updated the state using two different ways:</p>
<ol>
<li>By passing a function that returned an object. We did that inside the handleClick function.</li>
<li>By passing a regular object. We did that inside the interval callback.</li>
</ol>
<p>Both ways are acceptable, but the first one is preferred when you read and write to the state at the same time (which we do). Inside the interval callback, we’re only writing to the state and not reading it. When in doubt, always use the first function-as-argument syntax. It’s safer with race conditions because setState is actually an asynchronous method.</p>
<p>How do we update the state? We return an object with the new value of what we want to update. Notice how in both calls to setState, we’re only passing one property from the state field and not both. This is completely okay because setState actually merges what you pass it (the returned value of the function argument) with the existing state. So, not specifying a property while calling setState means that we wish to not change that property (but not delete it).</p>
<h1 id="8-React-将会响应你的变化"><a href="#8-React-将会响应你的变化" class="headerlink" title="#8: React 将会响应你的变化"></a>#8: React 将会响应你的变化</h1><p>React gets its name from the fact that it reacts to state changes (although not reactively, but on a schedule). There was a joke that React should have been named Schedule!</p>
<p>However, what we witness with the naked eye when the state of any component gets updated is that React reacts to that update and automatically reflects the update in the browser DOM (if needed).</p>
<p>Think of the render function’s input as both</p>
<ul>
<li><p>the props that get passed by the parent</p>
</li>
<li><p>the internal private state that can be updated anytime</p>
</li>
</ul>
<p>When the input of the render function changes, its output might change.</p>
<p>React keeps a record of the history of renders and when it sees that one render is different than the previous one, it’ll compute the difference between them and efficiently translate it into actual DOM operations that get executed in the DOM.</p>
<h1 id="9-React是你的代理人"><a href="#9-React是你的代理人" class="headerlink" title="#9: React是你的代理人"></a>#9: React是你的代理人</h1><p>You can think of React as the agent we hired to communicate with the browser. Take the current timestamp display above as an example. Instead of us manually going to the browser and invoking DOM API operations to find and update the p#timestamp element every second, we just changed a property on the state of the component and React did its job of communicating with the browser on our behalf. I believe this is the true reason why React is popular. We hate talking to Mr. browser (and the so many dialects of the DOM language that it speaks) and React volunteered to do all the talking for us, for free!</p>
<h1 id="10-组件周期-2"><a href="#10-组件周期-2" class="headerlink" title="#10: 组件周期 ( 2)"></a>#10: 组件周期 ( 2)</h1><p>Now that we know about the state of a component and how when that state changes some magic happens, let’s learn the last few concepts about that process.</p>
<ol>
<li><p>A component might need to re-render when its state gets updated or when its parent decides to change the props that it passed to the component</p>
</li>
<li><p>If the latter happens, React invokes another lifecycle method, componentWillReceiveProps.</p>
</li>
<li><p>If either the state object or the passed-in props are changed, React has an important decision to do. Should the component be updated in the DOM? This is why it invokes another important lifecycle method here, shouldComponentUpdate. This method is an actual question, so if you need to customize or optimize the render process on your own, you have to answer that question by returning either true or false.</p>
</li>
<li><p>If there is no custom shouldComponentUpdate specified, React defaults to a very smart thing that’s actually good enough in most situations.</p>
</li>
<li><p>First, React invokes another lifecycle method at this point, componentWillUpdate. React will then compute the new rendered output and compare it with the last rendered output.</p>
</li>
<li><p>If the rendered output is exactly the same, React does nothing (no need to talk to Mr. Browser).</p>
</li>
<li><p>If there is a difference, React takes that difference to the browser, as we’ve seen before.</p>
</li>
<li><p>In any case, since an update process happened anyway (even if the output was exactly the same), React invokes the final lifecycle method, componentDidUpdate.</p>
</li>
</ol>
<p>Lifecycle methods are actually escape hatches. If you’re not doing anything special, you can create full applications without them. They’re very handy for analyzing what is going on in the application and for further optimizing the performance of React updates.</p>
<p>That’s it. Believe it or not, with what you learned above (or parts of it, really), you can start creating some interesting React applications. If you’re hungry for more, check out my <a href="https://www.pluralsight.com/courses/react-js-getting-started" target="_blank" rel="external">Getting Started with React.js course at Pluralsight:</a></p>
<p>I also strongly recommend the <a href="http://amzn.to/2vVvU8L" target="_blank" rel="external">Learning React book</a> by Alex and Eve!</p>
<blockquote>
<p>This article was originally published on EdgeCoders here. The EdgeCoders version of the article uses interactive code examples which you can edit and re-run from within the article.</p>
</blockquote>
<p>Thanks for reading. If you found this article helpful, please recommend it and share it. Follow me for more articles on React.js and JavaScript.</p>

            </div>

            <!-- Comments -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                


            </div>
        </div>
    </div>
</article>

    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="" target="_blank">
                            <span class="fa-stack fa-sm">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-zhihu fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                    <li>
                        <a href="" target="_blank">
                            <span class="fa-stack fa-sm">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    <li>
                        <a href="" target="_blank">
                            <span class="fa-stack fa-sm">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                </ul>
                <p class="copyright text-muted">
                    copyright ©️  2016 Damon Blog<br>
                    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<a target="_blank" href="https://hexo.io/">Hexo</a>  theme by  <a href="/" target="_blank">damon</a>
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=stephenzhao&repo=hexo-theme-damon&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>
<img  src="https://www.gravatar.com/avatar/0674d0a22f7345e0625c9c7b39689c82?s=180" width="0" height="0" style="font-size: 0">


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap -->
<script src="/bootstrap/js/bootstrap.min.js"></script>

<!-- Bootstrap -->
<script src="/js/blog.js"></script>

<!-- Gallery -->
<script src="//cdn.rawgit.com/noelboss/featherlight/1.3.5/release/featherlight.min.js" type="text/javascript" charset="utf-8"></script>
<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<script type="text/javascript">
    var $imgs = $('.intro-header[data-imgs]');
    var imgs = $imgs.data('imgs');
    if (imgs.length > 0) {
        $imgs.css('background-image', 'url('+ imgs[Math.floor(Math.random() * 100) % imgs.length] +')')
    }
</script>
<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>




<!-- Google Analytics -->


<!-- baidu Analytics -->




</body>

</html>